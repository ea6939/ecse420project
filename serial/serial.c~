/*
-choose a block (block 1), step size 4
-choose another block
-compare two blocks (i.e. determine SAD)
-choose a different block to compare to block 1
-determine another SAD
-repeat 8 times
-choose best SAD, becomes new block 1, step size halved (now 2)
-repeat until step size is 1
*/

#include <stdio.h>
#include <stdlib.h>

int m = 50; //Number of rows in the image
int n = 100; //Number of columns in the image
int b; //Size of the block

//Previous image RGB
int **img_prev_r;
int **img_prev_g;
int **img_prev_b;

//Current image RGB
int **img_curr_r;
int **img_curr_g;
int **img_curr_b;

void store_images();
void process_images();
int compute_sum_rgb();

/*
BLOCKS:
0 | 1 | 2
3 | 4 | 5
6 | 7 | 8
*/

int main(int argc, char *argv[]) {
	if(argc != 2) {
		printf("Usage: ./pp <Block size>\n");
		exit(1);
	}

	b = atoi(argv[1]);

	store_images();

	process_images();
}

void store_images() {
	int i, j;

	printf("Storing images in matrices...\n");

	//Allocates memory to the matrices
	img_prev_r = (int **)malloc(m * sizeof(int*));
	img_prev_g = (int **)malloc(m * sizeof(int*));
	img_prev_b = (int **)malloc(m * sizeof(int*));

	img_curr_r = (int **)malloc(m * sizeof(int*));
	img_curr_g = (int **)malloc(m * sizeof(int*));
	img_curr_b = (int **)malloc(m * sizeof(int*));

	for(i = 0; i < m; i++) {
		img_prev_r[i] = (int *)malloc(n * sizeof(int));
		img_prev_g[i] = (int *)malloc(n * sizeof(int));
		img_prev_b[i] = (int *)malloc(n * sizeof(int));

		img_curr_r[i] = (int *)malloc(n * sizeof(int));
		img_curr_g[i] = (int *)malloc(n * sizeof(int));
		img_curr_b[i] = (int *)malloc(n * sizeof(int));
	}

	//Initializes matrices to 0
	for(i = 0; i < m; i++) {
		for(j = 0; j < n; j++) {
			img_prev_r[i][j] = 0;
			img_prev_g[i][j] = 0;
			img_prev_b[i][j] = 0;

			img_curr_r[i][j] = 0;
			img_curr_g[i][j] = 0;
			img_curr_b[i][j] = 0;
		}
	}

	int test = rand() % 50;
	img_prev_r[test][test+30] = 100;
	img_prev_g[test][test+30] = 100;
	img_curr_r[test][test+40] = 100;
	img_curr_g[test][test+40] = 100;
}

void process_images() {
	int i, j, k, l;

	printf("Computing the three step block matching algorithm...\n");

	//Property 1. Sum of RGB
	for(k = 0; k < m / b; k++) {
		for(l = 0; l < n / b; l++) {
			//Compare your own block first
			printf("|");
			//If the previous image's block was empty
			if(compute_sum_rgb(k * b, l * b, 0) == 0) {
				printf("(0,0)");
				continue;
			}
			//If the block is the same (no movement detected)
			if(compute_sum_rgb(k * b, l * b, 0) - compute_sum_rgb(k * b, l * b, 1) == 0) {
				printf("(0,0)");
				continue;
			}
			//Compare all 8 blocks around it
			int min_difference = -1;
			int block = 4;
			int old_value = compute_sum_rgb(k * b, l * b, 0);
			for(i = 0; i < 3; i++) {
				for(j = 0; j < 3; j++) {
					int new_value = compute_sum_rgb((k + (i - 1)) * b, (l + (j - 1)) * b, 1);
					//Same block which we have computed earlier
					if(i == 1 && j == 1) {
						continue;
					}
					else {
						//A better match has been found
						if((old_value - new_value) * (old_value - new_value) >= 0 && (old_value - new_value) * (old_value - new_value) < min_difference) {
							min_difference = (old_value - new_value) * (old_value - new_value);
							block = i * 3 + j;
						}
					}
				}
			}
			printf("BLOCK %d", block);
		}
		printf("|\n");
	}
}

//Input curr: 0 to calculate previous image, 1 for current image
int compute_sum_rgb(int k, int l, int curr) {
	int i, j;
	int total_RGB = 0;

	//Block out of bound
	if(k < 0 || l < 0 || k >= m || l >= n) {
		return -1;
	}

	//Loops through the block and adds up the RGB values
	for(i = k; i < k + b; i++) {
		for(j = l; j < l + b; j++) {
			if(curr == 0) {
				total_RGB += img_prev_r[i][j];
				total_RGB += img_prev_g[i][j];
				total_RGB += img_prev_b[i][j];
			}
			else if(curr == 1) {
				total_RGB += img_curr_r[i][j];
				total_RGB += img_curr_g[i][j];
				total_RGB += img_curr_b[i][j];
			}
			else {
				printf("Error reading block due to the input matrix\n");
				printf("Exiting...\n");
				exit(1);
			}
		}
	}
	//printf("Block %d %d %d: %d\n", k, l, curr, total_RGB);
	return total_RGB;
}
